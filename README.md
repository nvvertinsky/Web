# Web


# Производительность ввода/вывода
Данная тема не столь важна если приложение невелико и не создает большой нагрузки. Но по мере роста трафика тема все важнее. 

### Основы ввода вывода: 
Системные вызовы - это способ, с помощью которого программа просит ядро что-то сделать.
Все системные вызовы - блокирующие. Вопрос в том насколько долго они блокируют. 

Например в Linux есть методы: 
  - read(). Блокирующий поток вызов. При вызове мы сообщаем какой файл взять и в какой буфер доставить данные. И пока ядро не прочтет все данные, наша программа будет ждать. 
  - epoll_create(). Ядро принимает запрос, кладет его в очередь и сразу возвращает управление нашей программе. И наша программа продолжать выполняться.
  
Так же нужно знать, что каждый процесс получает собственную область памяти. А каждый поток использует память его процесса. 

### Диспечер: 
Каждое ядро недолго выполняет один поток/процесс, а затем переходит к следующему. Соответственно происходит переключенние контекста. Это занимает время. 
Какое-то переключение будет занимать меньше времени, какое-то больше. И чем больше потоков/процессов, тем больше переключений. 
Однако неблокирующие вызовы по существу говорят ядру: «Вызови меня только тогда, когда появятся новые данные или событие в одном из этих подключений». Эти вызовы созданы для эффективной обработки большой нагрузки по вводу/выводу и уменьшения количества переключений контекста.

Возьмем простые примеры некоторых язков программирования. Запросы к БД, HTTP запросы на другие ресурсы, внешние системы кеширования. 


### PHP + Apache: 
  - Создает процесс для каждого запроса. Каждому процессу выделяется память. 
  - PHP делает блокирующие вызовы ввода/вывода. То есть вызывает в Linux метод read.
  - Есть реализации неблокирующие ввод/вывод. Почему не подходит? Мб потому что разработчику тяжело на них разрабатывать? А в Go уже все есть под капотом?  


### Java + Tomcat :
  - Cоздает новый поток для каждого запроса. Память не выделяется потокам. 
  - Но если 10 тыс подключений, то значит 10к потоков. И каждая операция ввода/вывода блокирует поток. Получается диспечер будет переключаться постоянно между потоками. 
  - В java 1.4. появилась возможность выполнения неблокирующих вызовов ввода/вывода. Уточнить решает ли они проблему? Тяжело писать? А в Go под капотом? 

### Node: 
  - JS код выполняется в одном потоке. Получается один кусок кода блокирует следующий. Как цикл, нужно сначала обработать данные на первой итерации, а потом уже остальные. 	
  - И если у нас 10 тыс подключений, то этот цикл может убить все приложение. В рамках одного потока нужно поочередно уделять процессорное время каждому запросу.


### Go: 
Есть собственный диспечер. Использует концепцию горутин. Среда исполнения может приписывать горутину к потоку ОС и заставить исполнять ее. Или переводить ее в режим ожидания и не ассоцировать с потоком ОС.
Каждый запрос обрабатывается в отдельном горутине.
Среда выполнения автоматически распределяет горутины по такому кол-ву потоков ОС, какое она считает подходящим.

Но в любом случае выбор среды для создания проекта тесно связан с тем, насколько хорошо команда знакома с той или иной средой, а значит, и с общей потенциальной продуктивностью. 
Поэтому не для каждой команды будет целесообразно с головой погрузиться в разработку веб-приложений и сервисов на Node или Go. 
Одна из частых причин неиспользования тех или иных языков и/или сред — необходимость поиска разработчиков, знакомых с данным инструментом. 


### Веб сервера:
  - apache
  - nginx

### Бекенд:
  - Java   | Spring
  - nodeJS
  - C++    | Boost.Beast
  - Python | Flusk, Django
  - Go
  - PHP

### БД OLTP:
  - Oracle
  - PostgreSQL

### БД OLAP:
  - Колоночная?
  
### Список литературы: 
  - https://habr.com/ru/companies/vk/articles/329258/