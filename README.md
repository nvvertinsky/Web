# Web


## Виды web приложений

### Первое. Один процесс. 
  1. Выделяется процесс + память. В этом процессе запущено приложение. 
  2. Пришло 2 запроса одновременно. 
  3. Приложение сначала обрабатывает первый запрос. Выполняет бизнес логику. Например делает HTTP запрос на другой сервис. Это операция ввода/вывода. 
  4. Пока делается запрос в другой сервис сам процесс ждет. То есть просто простаивает. 
  5. Допустим от другого сервиса пришел ответ, процесс продолжил выполнять нашу бизнес-логику. 
  6. Заканчиваем обрабатывать первый запрос.
  7. Начинаем обрабатывать второй запрос. 

Так как все делает один процесс, то если запросов будет 1000, то это будет все очень медленно выполняться. 


### Второе. Несколько процессов. 
  1. Выделяется процесс + память. В этом процессе запущено приложение. 
  2. Пришло 2 запроса одновременно. 
  3. Приложение создает еще один процесс. Процессу выделяется своя память. 
  4. В этом отдельном процессе выполняется бизнес-логика с вводом/выводом. Для первого запроса.
  5. Для второго запроса тоже самое. 
  6. Основной процесс продолжает принимать остальные запросы. 
 
Уже лучше чем первый вариант. Будет быстрее. Т.к. каждый запрос выполняется в своем процессе. Но каждый процесс имеет свою память. 
И если будет 1000 запросов, то потребуется больше памяти. 
Плюс ядро процессора может выполнять одну задачу в один момент времени. Это значит что ядро процессора будет выполнять сначала первый процесс, остановится на половине, потом переключиться на второй.
Второй тоже сделает наполовину, потом переключится на первый и так далее. 
На эти переключения тоже нужно время. Если будут 1000 процессов, то ядро процессора будет постоянно переключаться между ними. 
На многоядерных процессорах, 1000 процессов будут распределяться по всем ядрах. Выполняться процессы будут быстрее. 
  
### Третье. Несколько потоков. 
  1. Выделяется процесс + память. В этом процессе запущено приложение. 
  2. Пришло 2 запроса одновременно. 
  3. Приложение создает еще поток. Поток использует ту же память что и процесс от которого он создан. 
  4. В этом отдельном потоке выполняется бизнес-логика с вводом/выводом. Для первого запроса.
  5. Для второго запроса тоже самое. 
  6. Основной процесс продолжает принимать остальные запросы. 

Лучше чем предыдущие варианты. Так как поток использует ту же память что с процесс. А значит памяти нужно меньше. 
Но ядро процессора так же выполняет один поток в один момент времени. Это значит что если будет 1000 потоков, то ядро будет так же переключаться между ними. 


## Проблема всех видов приложений. 
Поток/процесс большую часть времени ждет пока мы получим данные из другого сервиса или из БД. 
То есть поток ничего не делает в это время. Получается когда мы обращаемся к какому то сервису, происходит блокировка потока. Он ничего не делает.
Нужен механизм который заставлял поток/процесс делать что то другое, пока происходит операция ввода/вывода.



# Производительность ввода/вывода
Данная тема не столь важна если приложение невелико и не создает большой нагрузки. Но по мере роста трафика тема все важнее. 

### Основы ввода вывода: 
Системные вызовы - это способ, с помощью которого программа просит ядро что-то сделать.
Все системные вызовы - блокирующие. Вопрос в том насколько долго они блокируют. 

Например в Linux есть методы: 
  - read(). Блокирующий поток вызов. При вызове мы сообщаем какой файл взять и в какой буфер доставить данные. И пока ядро не прочтет все данные, наша программа будет ждать. 
  - epoll_create(). Ядро принимает запрос, кладет его в очередь и сразу возвращает управление нашей программе. И наша программа продолжать выполняться.
  
Так же нужно знать, что каждый процесс получает собственную область памяти. А каждый поток использует память его процесса. 

### Диспечер: 
Каждое ядро недолго выполняет один поток/процесс, а затем переходит к следующему. Соответственно происходит переключенние контекста. Это занимает время. 
Какое-то переключение будет занимать меньше времени, какое-то больше. И чем больше потоков/процессов, тем больше переключений. 
Однако неблокирующие вызовы по существу говорят ядру: «Вызови меня только тогда, когда появятся новые данные или событие в одном из этих подключений». Эти вызовы созданы для эффективной обработки большой нагрузки по вводу/выводу и уменьшения количества переключений контекста.

Возьмем простые примеры некоторых язков программирования. Запросы к БД, HTTP запросы на другие ресурсы, внешние системы кеширования. 


### PHP + Apache: 
  - Создает процесс для каждого запроса. Каждому процессу выделяется память. 
  - PHP делает блокирующие вызовы ввода/вывода. То есть вызывает в Linux метод read.
  - Есть реализации неблокирующие ввод/вывод. Почему не подходит? Мб потому что разработчику тяжело на них разрабатывать? А в Go уже все есть под капотом?  


### Java + Tomcat :
  - Cоздает новый поток для каждого запроса. Память не выделяется потокам. 
  - Но если 10 тыс подключений, то значит 10к потоков. И каждая операция ввода/вывода блокирует поток. Получается диспечер будет переключаться постоянно между потоками. 
  - В java 1.4. появилась возможность выполнения неблокирующих вызовов ввода/вывода. Уточнить решает ли они проблему? Тяжело писать? А в Go под капотом? 

### Node: 
  - JS код выполняется в одном потоке. Получается один кусок кода блокирует следующий. Как цикл, нужно сначала обработать данные на первой итерации, а потом уже остальные. 	
  - И если у нас 10 тыс подключений, то этот цикл может убить все приложение. В рамках одного потока нужно поочередно уделять процессорное время каждому запросу.


### Go: 
Есть собственный диспечер. Использует концепцию горутин. Среда исполнения может приписывать горутину к потоку ОС и заставить исполнять ее. Или переводить ее в режим ожидания и не ассоцировать с потоком ОС.
Каждый запрос обрабатывается в отдельном горутине.
Среда выполнения автоматически распределяет горутины по такому кол-ву потоков ОС, какое она считает подходящим.

Но в любом случае выбор среды для создания проекта тесно связан с тем, насколько хорошо команда знакома с той или иной средой, а значит, и с общей потенциальной продуктивностью. 
Поэтому не для каждой команды будет целесообразно с головой погрузиться в разработку веб-приложений и сервисов на Node или Go. 
Одна из частых причин неиспользования тех или иных языков и/или сред — необходимость поиска разработчиков, знакомых с данным инструментом. 


### Веб сервера:
  - apache
  - nginx

### Бекенд:
  - Java   | Spring
  - nodeJS
  - C++    | Boost.Beast
  - Python | Flusk, Django
  - Go
  - PHP

### БД OLTP:
  - Oracle
  - PostgreSQL

### БД OLAP:
  - Колоночная?
  
### Список литературы: 
  - https://habr.com/ru/companies/vk/articles/329258/